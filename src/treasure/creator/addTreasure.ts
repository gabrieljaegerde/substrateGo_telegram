import { botParams, getKeyboard } from "../../../config.js"
import { Markup } from "telegraf"
import TelegrafStatelessQuestion from "telegraf-stateless-question"
import _ from "lodash"
import { scan } from "../treasureHelpers.js"
import { createTreasureGuideMiddleware } from "./createTreasureGuide.js"
import Treasure from "../../models/treasure.js"
import Qr, { IQr } from "../../models/qr.js"
import { ITreasure } from "../../models/treasure.js"

const uploadTreasure = new TelegrafStatelessQuestion("ut", async (ctx: any) => {
    var message: string


    console.log("ctx1", ctx)
    if (!ctx.session.treasure) {
        console.log("ctx.session.guideStep1", ctx.session.guideStep)
        if (ctx.message.photo && ctx.session.guideStep === 1) {
            let photo = ctx.message.photo[ctx.message.photo.length - 1]
            let fileId = photo.file_id
            let file = await ctx.telegram.getFile(fileId)
            let url = await ctx.telegram.getFileLink(file.file_id)
            var result = await scan(url.href)
            if (result instanceof Error || result == "Couldn't find enough alignment patterns") {
                message = "An error occured when scanning the QR Code. Please send me a new photo."
                return uploadTreasure.replyWithMarkdown(ctx, message)
            }
            var qrId = result.replace(`https://t.me/${botParams.settings.botUsername}?start=`, "")
            let treasureDb: ITreasure = await Treasure.findOne({ code: qrId })
            let qrDb: IQr = await Qr.findOne({ id: qrId })
            if (!treasureDb && qrDb) {
                var newTreasure: ITreasure = new Treasure({
                    name: "",
                    code: qrId,
                    location: null,
                    creator: ctx.chat.id,
                    active: true,
                    hint: "",
                    description: "Congrats on finding this Treasure!",
                    file: botParams.settings.defaultFile,
                    date_of_entry: new Date()
                })
                ctx.session.treasure = newTreasure
                await botParams.bot.telegram.deleteMessage(ctx.session.guideMessage.chat.id, ctx.session.guideMessage.message_id)
                ctx.session.guideStep++
                ctx.session.guideMessage = await createTreasureGuideMiddleware.replyToContext(ctx)
                message = "Please now *send* me the üìç*location* of the treasure.\n\nThis *cannot* " +
                    "be changed later so make sure you only set it once the treasure is " +
                    "placed in its final location. To add the location, click on the '\uD83D\uDCCE' below " +
                    "and then click on *'Location'*.\n\n_If the treasure is hidden at your current location, simply " +
                    "click on _ *'Send My Current Location'*_. Otherwise drag the map so that the marker points to " +
                    "the treasures location. Then click _*'Send selected location'*."
                return uploadTreasure.replyWithMarkdown(ctx, message)
            }
            else if (treasureDb) {
                message = "This QR Code is already registered."
            }
            else {
                message = "Only QR Codes generated by this bot can be added. " +
                    "_Click on _*'Create Treasure'*_ and then _*'Generate QR Code'*_ in the menu below if you did not generate one yet._\n\n" +
                    "It is also possible that I just didn't read the QR code in the picture properly.\n" +
                    "If you think that is the case, then *please* send me a *new picture* of it."
                ctx.session.treasure = null
                ctx.session.guideMessage = null
                return uploadTreasure.replyWithMarkdown(ctx, message)
            }
            ctx.replyWithMarkdown(
                message,
                Markup.keyboard(await getKeyboard(ctx)).resize()
            )
        }
        else {
            message = `What you sent me is not a photo. I can only scan photos for QR codes.\n\nPlease send me a single photo (not file).`
            ctx.session.treasure = null
            ctx.session.guideMessage = null
            return uploadTreasure.replyWithMarkdown(ctx, message)
        }
    }
    else if (ctx.session.treasure && !ctx.session.treasure.location) {
        if (ctx.message.location && ctx.session.guideStep == 2) {
            ctx.session.treasure.location = ctx.message.location
            await botParams.bot.telegram.deleteMessage(ctx.session.guideMessage.chat.id, ctx.session.guideMessage.message_id)
            ctx.session.guideStep++
            ctx.session.guideMessage = await createTreasureGuideMiddleware.replyToContext(ctx)
            message = `To make it easier for you and others to identify this treasure, please now give it a descriptive name.`
            return uploadTreasure.replyWithMarkdown(ctx, message)
        }
        else {
            message = "The location you sent me was invalid. " +
                "Please try again. Send me the location of the marker " +
                "the same way you would send your current location to your friends..."
            return uploadTreasure.replyWithMarkdown(ctx, message)
        }
    }
    else {
        if (ctx.message.text && ctx.session.guideStep == 3) {
            ctx.session.treasure.name = ctx.message.text
            var treasureUpload: ITreasure = new Treasure(ctx.session.treasure)
            treasureUpload.save()
            ctx.session.treasure = null
            ctx.session.guideMessage = null
            var reply = "This treasure has been successfully added with the BASIC settings.\n\n" +
                "You can always go and spice up your treasures by hitting 'Edit treasure' in the creator menu!"
            ctx.replyWithMarkdown(
                reply,
                Markup.keyboard(await getKeyboard(ctx)).resize()
            )
        }
        else {
            message = "The name you sent me was invalid. " +
                "Please try again. Just send me a text message with the name in it please."
            return uploadTreasure.replyWithMarkdown(ctx, message)
        }
    }
})

export {
    uploadTreasure,
}